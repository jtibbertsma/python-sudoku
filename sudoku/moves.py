"""
Definitions for move classes. A Move is an object that mutates a State.
States should only changed by Moves. Moves also serve the purpose of
recording exactly what algorithms were used to solve a puzzle at every
step.

Most of the classes in this module do not add any real functionality
to their parents other than a new __repr__. We define a unique move class
for every algorithm for two reasons: 1) To define __repr__ so that we can
print move lists generated by subclasses of Solver, and 2) To count hit
rate stats for algorithms using isinstance on lists of moves.
"""

# We would use ABCMeta here for abstractmethod, but abc.__instancecheck__
# becomes somewhat of a bottleneck since isinstance(move, Guess) is called
# often in backtracking solvers.

#from abc import ABCMeta, abstractmethod

from .data import CandidateSet
from .errors import NoNextMoveError, MoveArgError

class Move:#(metaclass=ABCMeta):
    """An abc for move classes. Move classes keep a reference to a State,
    and define two operations, do and undo. Moves should be able to undo
    what they do perfectly, so that a puzzle can be rewound to the original
    state.
    """
    def __init__(self, state, **kwargs):
        if kwargs:
            raise TypeError('Superfluous keyword arguments')
        self.state = state

    #@abstractmethod
    def do(self):
        """Mutate the state in some way."""
        raise NotImplementedError

    #@abstractmethod
    def undo(self):
        """Undo what was done in do."""
        raise NotImplementedError

    #@abstractmethod
    def __repr__(self):
        raise NotImplementedError

class CandidateMutator(Move):
    """This is the parent class for any Move that eliminates candidates
    from cells in the state. Keeps a dictionary that maps keys to
    sets of candidates.
    """
    def __init__(self, state, *, change=None, **kwargs):
        # Allow the change dict to be passed into the constructor or
        # be created by the move object itself.
        self.change = change
        super().__init__(state, **kwargs)

    def do(self):
        """Eliminate elements from certain sets in the state's candidate
        grid.
        """
        # Possibly raises ContradictionError
        self.state.remove_candidates(self.change)

    def undo(self):
        """Return elements to sets in state.candidates."""
        self.state.add_candidates(self.change)

class EliminationMove(CandidateMutator):
    """This is the move used by the Elimination algorithm to solve a cell
    with one candidate. It also serves as a base class for any move that
    solves a cell, such as guesses. This keeps track of the solved key
    and the answer of that cell.
    """
    def __init__(self, state, *, key=None, digit=None, **kwargs):
        if key is None:
            raise MoveArgError('key')
        if digit is None:
            raise MoveArgError('digit')
        self.key = key
        self.digit = digit
        super().__init__(state, **kwargs)
        if self.change is None:
            change_set = CandidateSet(self.digit)
            self.change = {
                key: change_set
                    for key in self.state.candidate_in_keyset(
                        self.digit, self.state.oneset[self.key]
                    )
            }

    def do(self):
        """Set the position in the grid to the given digit."""
        self.state.clues[self.key] = self.digit
        super().do()

    def undo(self):
        """Remove the given digit from the grid."""
        super().undo()
        del self.state.clues[self.key]

    def __repr__(self):
        return '<Elimination: key={}, digit={}>'.format(self.key, self.digit+1)

class HiddenSingleMove(EliminationMove):
    """This is the move used by the hidden singles algorithm; keeps track of a
    flag that tells repr whether the hidden single was found in a row, group
    or column.
    """
    def __init__(self, state, *, mark=None, **kwargs):
        if mark is None:
            raise MoveArgError('mark')
        self.mark = mark
        super().__init__(state, **kwargs)

    def __repr__(self):
        return '<HiddenSingle in {}: key={}, digit={}>'.format(
            'Group' if self.mark == 0 else
            'Column' if self.mark == 1 else
            'Row', self.key, self.digit+1
        )

class LockedCandidateMove(CandidateMutator):
    """This doesn't add any functionality to CandidateMutator. It keeps track
    of the subgroup keys and digit to print. Since we're using the 'digit'
    attribute, we have to agree not to make a Move that inherits from this and
    EliminationMove. (Why would we want to?)
    """
    def __init__(self, state, *, subgroup=None, digit=None, mark=None, **kwargs):
        if subgroup is None:
            raise MoveArgError('subgroup')
        if digit is None:
            raise MoveArgError('digit')
        if mark is None:
            raise MoveArgError('mark')
        self.subgroup = subgroup
        self.digit = digit
        self.mark = mark
        super().__init__(state, **kwargs)

    def __repr__(self):
        return '<{}: subgroup={}, digit={}>'.format(
            'Pointing LockedCandidate' if self.mark == 0 else
            'LockedCandidate in Group',
            sorted(self.subgroup),
            self.digit+1
        )

class SetMove(CandidateMutator):
    """Base class for all moves used by the naked and hidden set algorithms.
    Each of these classes use the same attributes, but they have somewhat
    different meanings between naked and hidden set moves.
    """
    def __init__(self, state, *, keyset=None, digits=None, mark=None, **kwargs):
        if keyset is None:
            raise MoveArgError('keyset')
        if digits is None:
            raise MoveArgError('digits')
        if mark is None:
            raise MoveArgError('mark')
        self.keyset = keyset
        self.digits = digits
        self.mark = mark
        super().__init__(state, **kwargs)

class NakedSetMove(SetMove):
    """Base class for the moves used by the naked set series of algorithms.
    Keeps track of the keys in the naked set, the common candidates at these
    keys, and a mark which tells us where the set was found.
    """
    #@abstractmethod
    def __repr__(self):
        string = ('Row'           if self.mark == 0 else
                  'Column'        if self.mark == 1 else
                  'Group'         if self.mark == 2 else
                  'Row Subgroup'  if self.mark == 3 else
                  'Column Subgroup')
        return ' in {}: keys={}, digits={}>'.format(
            string, sorted(self.keyset),
            sorted([d+1 for d in self.digits])
        )

class NakedPairMove(NakedSetMove):
    def __repr__(self):
        return '<' + 'NakedPair' + super().__repr__()

class NakedTripleMove(NakedSetMove):
    def __repr__(self):
        return '<' + 'NakedTriple' + super().__repr__()

class NakedQuadMove(NakedSetMove):
    def __repr__(self):
        return '<' + 'NakedQuad' + super().__repr__()

class HiddenSetMove(SetMove):
    """This is the base class for the moves used by the hidden set series of
    algorithms. The attributes are the same as those in the naked set move
    classes.
    """
    #@abstractmethod
    def __repr__(self):
        string = ('Group'         if self.mark == 0 else
                  'Column'        if self.mark == 1 else
                  'Row')
        return ' in {}: keys={}, digits={}>'.format(
            string, sorted(self.keyset),
            sorted([d+1 for d in self.digits])
        )

class HiddenPairMove(HiddenSetMove):
    def __repr__(self):
        return '<' + 'HiddenPair' + super().__repr__()

class HiddenTripleMove(HiddenSetMove):
    def __repr__(self):
        return '<' + 'HiddenTriple' + super().__repr__()

class HiddenQuadMove(HiddenSetMove):
    def __repr__(self):
        return '<' + 'HiddenQuad' + super().__repr__()

class FishMove(CandidateMutator):
    """Base class for any moves used by fish algorithms, such as x-wing, swordfish,
    and their finned equivalents.
    """
    def __init__(self, state, *, fish=None, digit=None, **kwargs):
        if fish is None:
            raise MoveArgError('fish')
        if digit is None:
            raise MoveArgError('digit')
        self.fish = tuple(fish)
        self.digit = digit
        super().__init__(state, **kwargs)

class XWingMove(FishMove):
    """Class used by x-wing algorithms."""
    def __repr__(self):
        return '<XWing: rectangle={}, digit={}>'.format(self.fish, self.digit+1)

class FinnedFishMove(FishMove):
    """Base class for algorithms that find finned fishes. All FinnedFishes are
    also Fishes.
    """
    def __init__(self, state, *, fin=None, **kwargs):
        if fin is None:
            raise MoveArgError('fin')
        self.fin = fin
        super().__init__(state, **kwargs)

    def __repr__(self):
        return '<Finned{}, fin={}>'.format(
            super().__repr__()[1:-1], sorted(self.fin)
        )

class FinnedXWingMove(FinnedFishMove, XWingMove):
    pass

class SashimiFishMove(FinnedFishMove):
    """Base class for algorithms that find sashimi fishes. All
    SashimiFishes are also FinnedFishes, since a non-finned sashimi
    fish would be redundant.
    """
    def __repr__(self):
        return '<Sashimi' + super().__repr__()[7:]  # strip off '<Finned'

class SashimiXWingMove(SashimiFishMove, XWingMove):
    pass

class UniquenessTechnique(CandidateMutator):
    """Base class for moves that come from techniques that assume that
    the puzzle has a unique solution.
    """

class BUGMove(UniquenessTechnique):
    """This is the move for the BUGPlusOne algorithm. When we make more
    algorithms that use the BUG pattern, we'll subclass this, and move
    the repr for the BUGPlusOne algorithm into another subclass.
    """
    def __repr__(self):
        key = next(iter(self.change))
        digits = tuple(n+1 for n in self.change[key])
        return '<BUGPlusOne: key={}, eliminated {}>'.format(key, digits)

class UniqueRectangleMove(UniquenessTechnique):
    """Used for all of the various types of unique rectanlges that can
    be found.
    """
    def __init__(self, state, *, mark=None, rectangle=None, pair=None, **kwargs):
        if mark is None:
            raise MoveArgError('mark')
        if rectangle is None:
            raise MoveArgError('rectangle')
        if pair is None:
            raise MoveArgError('pair')
        self.mark = mark
        self.rectangle = rectangle
        self.pair = pair
        super().__init__(state, **kwargs)

    def __repr__(self):
        return '<UniqueRectangle (Type {}): rectangle={}, pair={}>'.format(
            self.mark, self.rectangle, self.pair
        )

### Backtracking and Gueses

class GuessElimination(CandidateMutator):
    """If we have to create a Backtrack move, we know that we've made a bad guess.
    This move comes one move after a Backtrack, and eliminates our bad guess.
    """
    def __repr__(self):
        key = next(iter(self.change))
        return '<GuessElimination: key={}, bad guess={}>'.format(
            key, next(iter(self.change[key]))+1
        )

class Backtrack(Move):
    """This move represents a backtrack to a guess. It calls undo on a list of
    moves and eliminates the bad guess.
    """
    def __init__(self, state, *, stack=None, why=None, **kwargs):
        if stack is None:
            raise MoveArgError('stack')
        if why is None:
            raise MoveArgError('why')
        self.stack, self.undos = self.splitstack(stack)
        self.why = why
        super().__init__(state, **kwargs)

    @staticmethod
    def splitstack(bt):
        """Split a stack into two lists, one up to the guess, and the second
        a list of moves to be undone.
        """
        for n, move in enumerate(reversed(bt),1):
            if isinstance(move, Guess) and move.remaining > 0:
                return bt[:-n], list(reversed(bt[-n:]))
        raise NoNextMoveError

    def do(self):
        """Undo each move in the undo list."""
        for move in self.undos:
            move.undo()
        # Eliminate the bad guess from the candidates grid.
        badguess = self.undos[-1]
        self.state.movehook = GuessElimination(self.state,
                                change={badguess.key: CandidateSet(badguess.digit)})

    def undo(self):
        """Redo all moves in reverse order."""
        for move in reversed(self.undos):
            move.do()

    def __repr__(self):
        num_undos = len(self.undos)
        return '<Backtrack: ({}), undo {} {}>'.format(
            self.why, num_undos, 'move' if num_undos == 1 else 'moves'
        )

class Guess(EliminationMove):
    """A guess made by a backtracking solver. In addition to simple move
    attributes, this keeps track of the number of candidates remaining
    in the cell we're guessing for. This is so that while backtracking,
    we can decide whether to stop at a particular guess or keep going.
    """
    def __init__(self, state, *, remaining=None, **kwargs):
        if remaining is None:
            raise MoveArgError('remaining')
        self.remaining = remaining
        super().__init__(state, **kwargs)

    #@abstractmethod
    def __repr__(self):
        return ': key={}, digit={}, {} other {}>'.format(
            self.key, self.digit+1, self.remaining,
            'possibility' if self.remaining == 1 else 'possibliities'
        )

class SimpleGuess(Guess):   ## Sledgehammer
    def __repr__(self):
        return '<' + 'SimpleGuess' + super().__repr__()

class RandomGuess(Guess):   ## Random
    def __repr__(self):
        return '<' + 'RandomGuess' + super().__repr__()
